// This file is part of midnightntwrk/example-counter.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pragma language_version 0.16;

import CompactStandardLibrary;

export ledger contractVersion: Uint<32>;
export ledger controllerPublicKey: Bytes<32>;
export ledger id: ContractAddress;
export ledger version: Counter;
export ledger createdAt: Uint<64>;
export ledger updatedAt: Uint<64>;
export ledger deactivatedAt: Uint<64>;
export ledger active: Boolean;
export ledger operationCount: Counter;
export ledger verificationMethods: Map<Opaque<"string">, VerificationMethod>;
export ledger authenticationRelation: Set<Opaque<"string">>;
export ledger assertionMethodRelation: Set<Opaque<"string">>;
export ledger keyAgreementRelation: Set<Opaque<"string">>;
export ledger capabilityInvocationRelation: Set<Opaque<"string">>;
export ledger capabilityDelegationRelation: Set<Opaque<"string">>;
export ledger services: Map<Opaque<"string">, Service>;

witness localSecretKey(): Bytes<32>;

export enum VerificationMethodType {
  Undefined,
  JsonWebKey
}

export enum VerificationMethodRelation {
  Undefined,
  Authentication,
  AssertionMethod,
  KeyAgreement,
  CapabilityInvocation,
  CapabilityDelegation
}

export enum KeyType {
  EC, RSA, oct, OKP
}

export enum CurveType {
  ed25519, Jubjub
}

export struct PublicKeyJwk {
  kty: KeyType,
  crv: CurveType,
  x: Field,
  y: Field,
}

export struct VerificationMethod {
  id: Opaque<"string">,
  type: VerificationMethodType,
  publicKeyJwk: PublicKeyJwk
};

export struct Service {
  id: Opaque<"string">,
  type: Opaque<"string">,
  serviceEndpoint: Vector<4, Opaque<"string">>,
}

export enum OperationType {
  Undefined, // is required to have the default values for the tagged structure and fixed size Vector
  AddVerificationMethod,
  UpdateVerificationMethod,
  RemoveVerificationMethod,
  AddVerificationMethodRelation,
  RemoveVerificationMethodRelation,
  AddService,
  UpdateService,
  RemoveService,
  Deactivate
}

export struct AddVerificationMethodOptions {
  verificationMethod: VerificationMethod,
}

export struct UpdateVerificationMethodOptions {
  verificationMethod: VerificationMethod,
}

export struct RemoveVerificationMethodOptions {
  id: Opaque<"string">,
}

export struct AddVerificationMethodRelationOptions {
  relation: VerificationMethodRelation,
  methodId: Opaque<"string">,
}

export struct RemoveVerificationMethodRelationOptions {
  relation: VerificationMethodRelation,
  methodId: Opaque<"string">,
}

export struct AddServiceOptions {
  service: Service,
}

export struct UpdateServiceOptions {
  service: Service
}

export struct RemoveServiceOptions {
  id: Opaque<"string">,
}

export struct DIDUpdateOperation {
  operationType: OperationType,
  addVerificationMethodOptions: AddVerificationMethodOptions,
  updateVerificationMethodOptions: UpdateVerificationMethodOptions,
  removeVerificationMethodOptions: RemoveVerificationMethodOptions,
  addVerificationMethodRelationOptions: AddVerificationMethodRelationOptions,
  removeVerificationMethodRelationOptions: RemoveVerificationMethodRelationOptions,
  addServiceOptions: AddServiceOptions,
  updateServiceOptions: UpdateServiceOptions,
  removeServiceOptions: RemoveServiceOptions,
}

constructor() {
  //TODO: clarify with the Midnight team why `id` is not set correctly (did.api.test.ts)
  contractVersion = 1;
  id = kernel.self();
  active = true;
  controllerPublicKey = disclose(publicKey(localSecretKey()));

  //createdAt = disclose(getEpoc());
}

//TODO: clarify with Midnight team how to find/deploy the smart contract with args
// constructor(operations: Vector<32, DIDUpdateOperation>) {
//   id = kernel.self();
//   active = true;

//   applyOperations(operations);
// }

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "did:controller:pk"), sk]);
}

export circuit applyOperations(operations: Vector<4, DIDUpdateOperation>): [] {
  assert(publicKey(localSecretKey()) == controllerPublicKey, "DID controller is allowed to update the DID only");
  assert(disclose(active), "Contract is not active");

  id = kernel.self();

  const previosOperationCount = operationCount.read();

  for (const operation of operations)
    if (disclose(operation.operationType) != OperationType.Undefined) {
      applyOperation(disclose(operation));
      operationCount.increment(1);
    }
  
  const appliedOperationCount = operationCount.read() - previosOperationCount;
  if (appliedOperationCount > 0)
    version.increment(1);
}

circuit applyOperation(operation: DIDUpdateOperation): [] {
  if (operation.operationType == OperationType.AddVerificationMethod) {
    addVerificationMethod(
      operation.addVerificationMethodOptions.verificationMethod
      );
  } else if (operation.operationType == OperationType.UpdateVerificationMethod) {
    updateVerificationMethod(
      operation.updateVerificationMethodOptions.verificationMethod
      );
  } else if (operation.operationType == OperationType.RemoveVerificationMethod) {
    removeVerificationMethod(
      operation.removeVerificationMethodOptions.id
    );
  } else if (operation.operationType == OperationType.AddVerificationMethodRelation) {
    addVerificationMethodRelation(
      operation.addVerificationMethodRelationOptions
    );
  } else if (operation.operationType == OperationType.RemoveVerificationMethodRelation) {
    removeVerificationMethodRelation(operation.removeVerificationMethodRelationOptions);
  } else if (operation.operationType == OperationType.AddService) {
    addService(operation.addServiceOptions);
  } else if (operation.operationType == OperationType.UpdateService) {
    updateService(operation.updateServiceOptions);
  } else if (operation.operationType == OperationType.RemoveService) {
    removeService(operation.removeServiceOptions);
  } else if (operation.operationType == OperationType.Deactivate) {
    deactivate();
  } else {
    // no-op for OperationType.Empty
  }
}

circuit addVerificationMethod(verificationMethod: VerificationMethod): [] {
  assert(disclose(active), "Contract is not active");
  
  const disclosedVerificationMethod = disclose(verificationMethod);
  assert(!verificationMethods.member(disclosedVerificationMethod.id), "Verification method already exists");

  verificationMethods.insert(disclosedVerificationMethod.id, disclosedVerificationMethod);
}

circuit updateVerificationMethod(verificationMethod: VerificationMethod): [] {
  assert(active, "Contract is not active");
  
  const disclosedVerificationMethod = disclose(verificationMethod);
  assert(verificationMethods.member(disclosedVerificationMethod.id), "Verification method does not exist");

  verificationMethods.remove(disclosedVerificationMethod.id);
  verificationMethods.insert(disclosedVerificationMethod.id, disclosedVerificationMethod);
}

circuit removeVerificationMethod(id: Opaque<"string">): [] {
  assert(active, "Contract is not active");

  const disclosedId = disclose(id);
  assert(verificationMethods.member(disclosedId), "Verification method does not exist");

  verificationMethods.remove(disclosedId);

  if (authenticationRelation.member(disclosedId)){
    authenticationRelation.remove(disclosedId);
  }

  if (assertionMethodRelation.member(disclosedId)){
    assertionMethodRelation.remove(disclosedId);
  }

  if (capabilityInvocationRelation.member(disclosedId)){
    capabilityInvocationRelation.remove(disclosedId);
  }

  if (keyAgreementRelation.member(disclosedId)){
    keyAgreementRelation.remove(disclosedId);
  }

  if (capabilityDelegationRelation.member(disclosedId)){
    capabilityDelegationRelation.remove(disclosedId);
  }
}

//TODO: discuss with the Midnight team why assertion doesn't work
circuit addVerificationMethodRelation(
  options: AddVerificationMethodRelationOptions
): [] {
  assert(active, "Contract is not active");

  const relation = options.relation;
  const methodId = options.methodId;
  assert(verificationMethods.member(methodId), "Verification method does not exist");

  if (relation == VerificationMethodRelation.Authentication) {
    assert(!authenticationRelation.member(methodId), "Method already in 'authentication' relation");
    authenticationRelation.insert(methodId);
  } else if (relation == VerificationMethodRelation.AssertionMethod) {
    assert(!assertionMethodRelation.member(methodId), "Method already in 'assertion' method relation");
    assertionMethodRelation.insert(methodId);
  } else if (relation == VerificationMethodRelation.KeyAgreement) {
    assert(!keyAgreementRelation.member(methodId), "Method already in 'key agreement' relation");
    keyAgreementRelation.insert(methodId);
  } else if (relation == VerificationMethodRelation.CapabilityInvocation) {
    assert(!capabilityInvocationRelation.member(methodId), "Method already in 'capability invocation' relation");
    capabilityInvocationRelation.insert(methodId);
  } else if (relation == VerificationMethodRelation.CapabilityDelegation) {
    assert(!capabilityDelegationRelation.member(methodId), "Method already in 'capability delegation' relation");
    capabilityDelegationRelation.insert(methodId);
  }
}

circuit removeVerificationMethodRelation(
  options: RemoveVerificationMethodRelationOptions
): [] {
  assert(active, "Contract is not active");

  const methodId = options.methodId;
  const relation = options.relation;

  assert(verificationMethods.member(methodId), "Verification method does not exist");

  if (relation == VerificationMethodRelation.Authentication) {
    assert(authenticationRelation.member(methodId), "Method not in 'authentication' relation");
    authenticationRelation.remove(methodId);
  } else if (relation == VerificationMethodRelation.AssertionMethod) {
    assert(assertionMethodRelation.member(methodId), "Method not in 'assertion' method relation");
    assertionMethodRelation.remove(methodId);
  } else if (relation == VerificationMethodRelation.KeyAgreement) {
    assert(keyAgreementRelation.member(methodId), "Method not in 'key agreement' relation");
    keyAgreementRelation.remove(methodId);
  } else if (relation == VerificationMethodRelation.CapabilityInvocation) {
    assert(capabilityInvocationRelation.member(methodId), "Method not in 'capability invocation' relation");
    capabilityInvocationRelation.remove(methodId);
  } else if (relation == VerificationMethodRelation.CapabilityDelegation) {
    assert(capabilityDelegationRelation.member(methodId), "Method not in 'capability delegation' relation");
    capabilityDelegationRelation.remove(methodId);
  }
}

circuit addService(options: AddServiceOptions): [] {
  assert(active, "Contract is not active");
  const id = options.service.id;
  assert(!services.member(id), "Service with a given id already exists");
  services.insert(id, options.service);
}

circuit updateService(options: UpdateServiceOptions): [] {
  assert(active, "Contract is not active");
  const id = options.service.id;
  assert(services.member(id), "Service with a given id does not exist");
  services.remove(id);
  services.insert(id, options.service);
}

circuit removeService(options: RemoveServiceOptions): [] {
  assert(active, "Contract is not active");
  const id = options.id;
  assert(services.member(id), "Service with a given id does not exist");
  services.remove(id);
}

circuit deactivate(): [] {
  assert(active, "DID is already inactive");
  active = false;
}
